\chapter{Аналитические раздел}

Данный раздел включает в себя формализацию задачи и анализ протокола HTTP, паттерна thread pool и мультиплексора poll.

\section{Требования к серверу}

Для реализуемого сервера выдвигается следующий требования:
\begin{itemize}[label=---]
	\item поддержка запросов GET и HEAD и статусов 200, 403, 404;
	\item ответ на неподдерживаемые запросы статусом 405;
	\item выставление content type в зависимости от типа файла;
	\item корректная передача файлов размером в 100мб;
	\item защита от выхода за пределы root директории сервера;
	\item стабильная работа сервера.
\end{itemize}

\section{Протокол HTTP}

HTTP (протокол передачи гипертекста) --- это протокол прикладного уровня. Реализуется в двух частях приложений: клиентской и серверной. Клиенты и сервер общаются друг с другом, обмениваясь сообщениями. Протокол определяет структуру этих сообщений и порядок обмена~\cite{seti}.

HTTP использует TCP в качестве базового транспортного протокола. Сначала HTTP--клиент инициирует TCP--соединение с сервером, по нему клиент отправляет HTTP--запрос. HTTP--сервер принимает запрос и отправляет HTTP--ответ. Также за счёт использования TCP в HTTP гарантируется доставка всех сообщений~\cite{seti}. 

Сервер отправляет запрошенные файлы без сохранения какой-либо информации о нем. Если некоторый объект будет многократно запрошен, то он будет каждый раз полностью отправлен в ответе. Поэтому HTTP называют протоколом
без сохранения состояния~\cite{seti}.

HTTP работает с непостоянными и постоянными соединениями. В первом случае каждая пара запрос-ответ отправляются через отдельные соединения, а во втором через одно. Непостоянные соединения применяются по умолчанию в версии 1.0 HTTP, в то время как постоянные соединения в версии HTTP 1.1. Краткосрочные соединения имеют два больших недостатка: требуется значительное время на установку нового соединения, и то, что эффективность TCP-соединения улучшается только по прошествии некоторого времени от начала его использования. У постоянных соединений есть свои недочёты; даже работая вхолостую, они потребляют ресурсы сервера, а при высокой нагрузке могут проводиться DoS-атаки. Соединения управляются заголовком Connection. Значение close указывает, что клиент или сервер хотели бы закрыть соединение. keep-alive указывает, что клиент хотел бы сохранить соединение активным~\cite{conn}.

Постоянные соединения поддерживаю конвейерную обработку. Это процесс отсылки последовательных запросов по одному постоянному соединению не дожидаясь ответа. Таким образом избегают задержки соединения. Не все типы запросов HTTP позволяют конвейерную обработку: только идемпотентные методы, а именно GET, HEAD, PUT и DELETE, можно перезапускать безопасно: в случае сбоя содержимое конвейерной передачи можно просто повторить. Демонстрация работы HTTP с различными типами соединений представлена на рисунке \ref{img:http}~\cite{conn}.

\imgScale{0.36}{http}{HTTP с различными типами соединений}
\FloatBarrier

HTTP--запрос представлен в обычном текстовом формате ASCII. Первая строка HTTP-сообщения называется строкой запроса; следующие строки называются строками заголовка. В строке запроса содержатся: метод, URL, версия протокола. Заголовки записываются как пары имя: значение и разделены символом новой строки. Формат запроса представлен на рисунке \ref{img:http-req}~\cite{seti}.

\imgScale{0.7}{http-req}{Общий формат сообщения--запроса HTTP}
\FloatBarrier

HTTP--ответ тоже представляется в виде текста, воспринимаемого человеком и состоит из строки состояния, заголовков и тела. Строка состояния содержит версию протокола, код состояния и соответствующее сообщение. Формат запроса представлен на рисунке \ref{img:http-resp}~\cite{seti}.

\imgScale{0.7}{http-resp}{Общий формат сообщения-ответа протокола HTTP}
\FloatBarrier

\section{Паттерн thread pool}

Пул потоков --- то шаблон проектирования программного обеспечения, обеспечивающий параллельное выполнение программ. Он поддерживает множество потоков, ожидающих поступления задач для одновременного выполнения. Количество потоков настраиваемый параметр, как правило, оптимальные количество совпадает с количеством логических ядер. Малое количество потоков может работать недостаточно быстро, а чрезмерно большое количество приводит к пустой трате вычислительных ресурсов~\cite{tpool}.

Преимуществ пула потоков по сравнению с созданием нового потока для каждой задачи является то, что затраты на создание и уничтожение потоков ограничиваются первоначальным созданием, а не при выполнении каждой задачи. Но это требует дополнительной синхронизации потоков~\cite{tpool}.

Для выполнения задания необходимо поставить его в очередь, читаемую воркерами. Результат, если он требуется, забирается из второй очереди, которая заполняется воркерами. Сами же потоки крутятся в бесконечном цикле, на каждой итерации которого проверяют наличие работ на выполнения и собственно выполняют их. Каждое обращение к очереди выполняется в режиме монопольного доступа для избежания состояния гонки, что достилается за счёт использования примитивов синхронизацию. Схема работы представлена на рисунке \ref{img:tpool}~\cite{tpool}.

\imgScale{0.3}{tpool}{Схема работы thread pool}
\FloatBarrier

\section{Мультиплексирование}

Сокет --- это программный интерфейс для обмена данными данными между процессорами как на одном компьютере, так и на различных. Представляют собой конечную точку соединения. При сетевом взаимодействии сокеты являются абстракцией над IP--адресом и портом.

Возможность сообщить ядру, о необходимости получать информации о том, что на одном или нескольких дескрипторов из множества выполнилось какое-либо условие ввода--вывода, называется мультиплексированием. poll --- функция мультиплексирования, которая использует блокировку ввода-вывода с мультиплексированием, алгоритм работы представлен на рисунке. Основными достоинствами её являются неограниченное количество слушаемых сокетов и неизменность массива слушаемых сокетов, что освобождает от его постоянной перезаписи. pool принимает массив содержащий номера дескрипторов и интересующие события.  

\imgScale{0.7}{poll}{Модель мультиплексирования ввода--вывода}
\FloatBarrier

\section*{Вывод}

В данном раздел была формализована задача и рассмотрены протокола HTTP, паттерн thread pool и мультиплексор poll.

